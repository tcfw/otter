// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	cid "github.com/ipfs/go-cid"

	format "github.com/ipfs/go-ipld-format"

	id "github.com/tcfw/otter/pkg/id"

	mock "github.com/stretchr/testify/mock"

	otter "github.com/tcfw/otter/pkg/otter"

	peer "github.com/libp2p/go-libp2p/core/peer"

	zap "go.uber.org/zap"
)

// MockOtter is an autogenerated mock type for the Otter type
type MockOtter struct {
	mock.Mock
}

type MockOtter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOtter) EXPECT() *MockOtter_Expecter {
	return &MockOtter_Expecter{mock: &_m.Mock}
}

// Crypto provides a mock function with no fields
func (_m *MockOtter) Crypto() otter.Cryptography {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Crypto")
	}

	var r0 otter.Cryptography
	if rf, ok := ret.Get(0).(func() otter.Cryptography); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(otter.Cryptography)
		}
	}

	return r0
}

// MockOtter_Crypto_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Crypto'
type MockOtter_Crypto_Call struct {
	*mock.Call
}

// Crypto is a helper method to define mock.On call
func (_e *MockOtter_Expecter) Crypto() *MockOtter_Crypto_Call {
	return &MockOtter_Crypto_Call{Call: _e.mock.On("Crypto")}
}

func (_c *MockOtter_Crypto_Call) Run(run func()) *MockOtter_Crypto_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockOtter_Crypto_Call) Return(_a0 otter.Cryptography) *MockOtter_Crypto_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_Crypto_Call) RunAndReturn(run func() otter.Cryptography) *MockOtter_Crypto_Call {
	_c.Call.Return(run)
	return _c
}

// DHTProvide provides a mock function with given fields: ctx, key, announce
func (_m *MockOtter) DHTProvide(ctx context.Context, key cid.Cid, announce bool) error {
	ret := _m.Called(ctx, key, announce)

	if len(ret) == 0 {
		panic("no return value specified for DHTProvide")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, bool) error); ok {
		r0 = rf(ctx, key, announce)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOtter_DHTProvide_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DHTProvide'
type MockOtter_DHTProvide_Call struct {
	*mock.Call
}

// DHTProvide is a helper method to define mock.On call
//   - ctx context.Context
//   - key cid.Cid
//   - announce bool
func (_e *MockOtter_Expecter) DHTProvide(ctx interface{}, key interface{}, announce interface{}) *MockOtter_DHTProvide_Call {
	return &MockOtter_DHTProvide_Call{Call: _e.mock.On("DHTProvide", ctx, key, announce)}
}

func (_c *MockOtter_DHTProvide_Call) Run(run func(ctx context.Context, key cid.Cid, announce bool)) *MockOtter_DHTProvide_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(bool))
	})
	return _c
}

func (_c *MockOtter_DHTProvide_Call) Return(_a0 error) *MockOtter_DHTProvide_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_DHTProvide_Call) RunAndReturn(run func(context.Context, cid.Cid, bool) error) *MockOtter_DHTProvide_Call {
	_c.Call.Return(run)
	return _c
}

// DHTSearchProviders provides a mock function with given fields: ctx, key, max
func (_m *MockOtter) DHTSearchProviders(ctx context.Context, key cid.Cid, max int) ([]peer.AddrInfo, error) {
	ret := _m.Called(ctx, key, max)

	if len(ret) == 0 {
		panic("no return value specified for DHTSearchProviders")
	}

	var r0 []peer.AddrInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, int) ([]peer.AddrInfo, error)); ok {
		return rf(ctx, key, max)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, int) []peer.AddrInfo); ok {
		r0 = rf(ctx, key, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.AddrInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, int) error); ok {
		r1 = rf(ctx, key, max)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOtter_DHTSearchProviders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DHTSearchProviders'
type MockOtter_DHTSearchProviders_Call struct {
	*mock.Call
}

// DHTSearchProviders is a helper method to define mock.On call
//   - ctx context.Context
//   - key cid.Cid
//   - max int
func (_e *MockOtter_Expecter) DHTSearchProviders(ctx interface{}, key interface{}, max interface{}) *MockOtter_DHTSearchProviders_Call {
	return &MockOtter_DHTSearchProviders_Call{Call: _e.mock.On("DHTSearchProviders", ctx, key, max)}
}

func (_c *MockOtter_DHTSearchProviders_Call) Run(run func(ctx context.Context, key cid.Cid, max int)) *MockOtter_DHTSearchProviders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cid.Cid), args[2].(int))
	})
	return _c
}

func (_c *MockOtter_DHTSearchProviders_Call) Return(_a0 []peer.AddrInfo, _a1 error) *MockOtter_DHTSearchProviders_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOtter_DHTSearchProviders_Call) RunAndReturn(run func(context.Context, cid.Cid, int) ([]peer.AddrInfo, error)) *MockOtter_DHTSearchProviders_Call {
	_c.Call.Return(run)
	return _c
}

// DistributedStorage provides a mock function with given fields: _a0
func (_m *MockOtter) DistributedStorage(_a0 id.PublicID) (otter.DistributedStorage, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for DistributedStorage")
	}

	var r0 otter.DistributedStorage
	var r1 error
	if rf, ok := ret.Get(0).(func(id.PublicID) (otter.DistributedStorage, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(id.PublicID) otter.DistributedStorage); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(otter.DistributedStorage)
		}
	}

	if rf, ok := ret.Get(1).(func(id.PublicID) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOtter_DistributedStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DistributedStorage'
type MockOtter_DistributedStorage_Call struct {
	*mock.Call
}

// DistributedStorage is a helper method to define mock.On call
//   - _a0 id.PublicID
func (_e *MockOtter_Expecter) DistributedStorage(_a0 interface{}) *MockOtter_DistributedStorage_Call {
	return &MockOtter_DistributedStorage_Call{Call: _e.mock.On("DistributedStorage", _a0)}
}

func (_c *MockOtter_DistributedStorage_Call) Run(run func(_a0 id.PublicID)) *MockOtter_DistributedStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(id.PublicID))
	})
	return _c
}

func (_c *MockOtter_DistributedStorage_Call) Return(_a0 otter.DistributedStorage, _a1 error) *MockOtter_DistributedStorage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOtter_DistributedStorage_Call) RunAndReturn(run func(id.PublicID) (otter.DistributedStorage, error)) *MockOtter_DistributedStorage_Call {
	_c.Call.Return(run)
	return _c
}

// HostID provides a mock function with no fields
func (_m *MockOtter) HostID() peer.ID {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for HostID")
	}

	var r0 peer.ID
	if rf, ok := ret.Get(0).(func() peer.ID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(peer.ID)
	}

	return r0
}

// MockOtter_HostID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HostID'
type MockOtter_HostID_Call struct {
	*mock.Call
}

// HostID is a helper method to define mock.On call
func (_e *MockOtter_Expecter) HostID() *MockOtter_HostID_Call {
	return &MockOtter_HostID_Call{Call: _e.mock.On("HostID")}
}

func (_c *MockOtter_HostID_Call) Run(run func()) *MockOtter_HostID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockOtter_HostID_Call) Return(_a0 peer.ID) *MockOtter_HostID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_HostID_Call) RunAndReturn(run func() peer.ID) *MockOtter_HostID_Call {
	_c.Call.Return(run)
	return _c
}

// IPLD provides a mock function with no fields
func (_m *MockOtter) IPLD() format.DAGService {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IPLD")
	}

	var r0 format.DAGService
	if rf, ok := ret.Get(0).(func() format.DAGService); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(format.DAGService)
		}
	}

	return r0
}

// MockOtter_IPLD_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPLD'
type MockOtter_IPLD_Call struct {
	*mock.Call
}

// IPLD is a helper method to define mock.On call
func (_e *MockOtter_Expecter) IPLD() *MockOtter_IPLD_Call {
	return &MockOtter_IPLD_Call{Call: _e.mock.On("IPLD")}
}

func (_c *MockOtter_IPLD_Call) Run(run func()) *MockOtter_IPLD_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockOtter_IPLD_Call) Return(_a0 format.DAGService) *MockOtter_IPLD_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_IPLD_Call) RunAndReturn(run func() format.DAGService) *MockOtter_IPLD_Call {
	_c.Call.Return(run)
	return _c
}

// Logger provides a mock function with given fields: component
func (_m *MockOtter) Logger(component string) *zap.Logger {
	ret := _m.Called(component)

	if len(ret) == 0 {
		panic("no return value specified for Logger")
	}

	var r0 *zap.Logger
	if rf, ok := ret.Get(0).(func(string) *zap.Logger); ok {
		r0 = rf(component)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*zap.Logger)
		}
	}

	return r0
}

// MockOtter_Logger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logger'
type MockOtter_Logger_Call struct {
	*mock.Call
}

// Logger is a helper method to define mock.On call
//   - component string
func (_e *MockOtter_Expecter) Logger(component interface{}) *MockOtter_Logger_Call {
	return &MockOtter_Logger_Call{Call: _e.mock.On("Logger", component)}
}

func (_c *MockOtter_Logger_Call) Run(run func(component string)) *MockOtter_Logger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockOtter_Logger_Call) Return(_a0 *zap.Logger) *MockOtter_Logger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_Logger_Call) RunAndReturn(run func(string) *zap.Logger) *MockOtter_Logger_Call {
	_c.Call.Return(run)
	return _c
}

// Protocols provides a mock function with no fields
func (_m *MockOtter) Protocols() otter.Protocols {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Protocols")
	}

	var r0 otter.Protocols
	if rf, ok := ret.Get(0).(func() otter.Protocols); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(otter.Protocols)
		}
	}

	return r0
}

// MockOtter_Protocols_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Protocols'
type MockOtter_Protocols_Call struct {
	*mock.Call
}

// Protocols is a helper method to define mock.On call
func (_e *MockOtter_Expecter) Protocols() *MockOtter_Protocols_Call {
	return &MockOtter_Protocols_Call{Call: _e.mock.On("Protocols")}
}

func (_c *MockOtter_Protocols_Call) Run(run func()) *MockOtter_Protocols_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockOtter_Protocols_Call) Return(_a0 otter.Protocols) *MockOtter_Protocols_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_Protocols_Call) RunAndReturn(run func() otter.Protocols) *MockOtter_Protocols_Call {
	_c.Call.Return(run)
	return _c
}

// ResolveOtterNodesForKey provides a mock function with given fields: ctx, _a1
func (_m *MockOtter) ResolveOtterNodesForKey(ctx context.Context, _a1 id.PublicID) ([]peer.ID, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ResolveOtterNodesForKey")
	}

	var r0 []peer.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, id.PublicID) ([]peer.ID, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, id.PublicID) []peer.ID); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.ID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, id.PublicID) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOtter_ResolveOtterNodesForKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveOtterNodesForKey'
type MockOtter_ResolveOtterNodesForKey_Call struct {
	*mock.Call
}

// ResolveOtterNodesForKey is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 id.PublicID
func (_e *MockOtter_Expecter) ResolveOtterNodesForKey(ctx interface{}, _a1 interface{}) *MockOtter_ResolveOtterNodesForKey_Call {
	return &MockOtter_ResolveOtterNodesForKey_Call{Call: _e.mock.On("ResolveOtterNodesForKey", ctx, _a1)}
}

func (_c *MockOtter_ResolveOtterNodesForKey_Call) Run(run func(ctx context.Context, _a1 id.PublicID)) *MockOtter_ResolveOtterNodesForKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(id.PublicID))
	})
	return _c
}

func (_c *MockOtter_ResolveOtterNodesForKey_Call) Return(_a0 []peer.ID, _a1 error) *MockOtter_ResolveOtterNodesForKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOtter_ResolveOtterNodesForKey_Call) RunAndReturn(run func(context.Context, id.PublicID) ([]peer.ID, error)) *MockOtter_ResolveOtterNodesForKey_Call {
	_c.Call.Return(run)
	return _c
}

// Storage provides a mock function with no fields
func (_m *MockOtter) Storage() otter.StorageClasses {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Storage")
	}

	var r0 otter.StorageClasses
	if rf, ok := ret.Get(0).(func() otter.StorageClasses); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(otter.StorageClasses)
		}
	}

	return r0
}

// MockOtter_Storage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Storage'
type MockOtter_Storage_Call struct {
	*mock.Call
}

// Storage is a helper method to define mock.On call
func (_e *MockOtter_Expecter) Storage() *MockOtter_Storage_Call {
	return &MockOtter_Storage_Call{Call: _e.mock.On("Storage")}
}

func (_c *MockOtter_Storage_Call) Run(run func()) *MockOtter_Storage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockOtter_Storage_Call) Return(_a0 otter.StorageClasses) *MockOtter_Storage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_Storage_Call) RunAndReturn(run func() otter.StorageClasses) *MockOtter_Storage_Call {
	_c.Call.Return(run)
	return _c
}

// UI provides a mock function with no fields
func (_m *MockOtter) UI() otter.UI {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for UI")
	}

	var r0 otter.UI
	if rf, ok := ret.Get(0).(func() otter.UI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(otter.UI)
		}
	}

	return r0
}

// MockOtter_UI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UI'
type MockOtter_UI_Call struct {
	*mock.Call
}

// UI is a helper method to define mock.On call
func (_e *MockOtter_Expecter) UI() *MockOtter_UI_Call {
	return &MockOtter_UI_Call{Call: _e.mock.On("UI")}
}

func (_c *MockOtter_UI_Call) Run(run func()) *MockOtter_UI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockOtter_UI_Call) Return(_a0 otter.UI) *MockOtter_UI_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_UI_Call) RunAndReturn(run func() otter.UI) *MockOtter_UI_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForBootstrap provides a mock function with given fields: ctx
func (_m *MockOtter) WaitForBootstrap(ctx context.Context) chan struct{} {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WaitForBootstrap")
	}

	var r0 chan struct{}
	if rf, ok := ret.Get(0).(func(context.Context) chan struct{}); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan struct{})
		}
	}

	return r0
}

// MockOtter_WaitForBootstrap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForBootstrap'
type MockOtter_WaitForBootstrap_Call struct {
	*mock.Call
}

// WaitForBootstrap is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockOtter_Expecter) WaitForBootstrap(ctx interface{}) *MockOtter_WaitForBootstrap_Call {
	return &MockOtter_WaitForBootstrap_Call{Call: _e.mock.On("WaitForBootstrap", ctx)}
}

func (_c *MockOtter_WaitForBootstrap_Call) Run(run func(ctx context.Context)) *MockOtter_WaitForBootstrap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockOtter_WaitForBootstrap_Call) Return(_a0 chan struct{}) *MockOtter_WaitForBootstrap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOtter_WaitForBootstrap_Call) RunAndReturn(run func(context.Context) chan struct{}) *MockOtter_WaitForBootstrap_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOtter creates a new instance of MockOtter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOtter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOtter {
	mock := &MockOtter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
